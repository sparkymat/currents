// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries.sql

package dbx

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sparkymat/currents/internal/dbtypes"
)

const addTopicToMediaItem = `-- name: AddTopicToMediaItem :exec
INSERT INTO media_item_topics
(user_id, media_item_id, topic_id)
VALUES
($1::uuid, $2::uuid, $3::uuid)
`

type AddTopicToMediaItemParams struct {
	UserID      uuid.UUID
	MediaItemID uuid.UUID
	TopicID     uuid.UUID
}

func (q *Queries) AddTopicToMediaItem(ctx context.Context, arg AddTopicToMediaItemParams) error {
	_, err := q.db.Exec(ctx, addTopicToMediaItem, arg.UserID, arg.MediaItemID, arg.TopicID)
	return err
}

const confirmTopicForMediaItem = `-- name: ConfirmTopicForMediaItem :exec
UPDATE media_item_topics
SET confirmed_at = CURRENT_TIMESTAMP
WHERE user_id = $1::uuid AND media_item_id = $2::uuid AND topic_id = $3::uuid
`

type ConfirmTopicForMediaItemParams struct {
	UserID      uuid.UUID
	MediaItemID uuid.UUID
	TopicID     uuid.UUID
}

func (q *Queries) ConfirmTopicForMediaItem(ctx context.Context, arg ConfirmTopicForMediaItemParams) error {
	_, err := q.db.Exec(ctx, confirmTopicForMediaItem, arg.UserID, arg.MediaItemID, arg.TopicID)
	return err
}

const countSearchedMediaItems = `-- name: CountSearchedMediaItems :one
SELECT COUNT(*)
  FROM media_items
  WHERE user_id = $1::uuid
    AND title ILIKE '%' || $2::text || '%'
    AND state = 'processed'
`

type CountSearchedMediaItemsParams struct {
	UserID uuid.UUID
	Query  string
}

func (q *Queries) CountSearchedMediaItems(ctx context.Context, arg CountSearchedMediaItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchedMediaItems, arg.UserID, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchedTopics = `-- name: CountSearchedTopics :one
SELECT COUNT(*)
  FROM topics
  WHERE user_id = $1::uuid
    AND name ILIKE '%' || $2::text || '%'
`

type CountSearchedTopicsParams struct {
	UserID uuid.UUID
	Query  string
}

func (q *Queries) CountSearchedTopics(ctx context.Context, arg CountSearchedTopicsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchedTopics, arg.UserID, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMediaItem = `-- name: CreateMediaItem :one
INSERT INTO media_items
(user_id, item_type, title, url, published_at)
VALUES
($1::uuid, $2::media_item_type, $3::text, $4::text, $5::timestamp)
RETURNING id, user_id, title, url, item_type, published_at, created_at, updated_at, state, video_file_path, thumbnail_file_path, subtitle_file_paths, transcript, metadata
`

type CreateMediaItemParams struct {
	UserID      uuid.UUID
	ItemType    MediaItemType
	Title       string
	Url         string
	PublishedAt pgtype.Timestamp
}

func (q *Queries) CreateMediaItem(ctx context.Context, arg CreateMediaItemParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, createMediaItem,
		arg.UserID,
		arg.ItemType,
		arg.Title,
		arg.Url,
		arg.PublishedAt,
	)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.ItemType,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
		&i.VideoFilePath,
		&i.ThumbnailFilePath,
		&i.SubtitleFilePaths,
		&i.Transcript,
		&i.Metadata,
	)
	return i, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO topics
(user_id, title, description)
VALUES
($1::uuid, $2::text, $3::text)
RETURNING id, user_id, name, description, created_at, updated_at
`

type CreateTopicParams struct {
	UserID      uuid.UUID
	Title       string
	Description string
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, createTopic, arg.UserID, arg.Title, arg.Description)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  name, username, encrypted_password
) VALUES (
  $1::text, $2::text, $3::text
) RETURNING id, name, username, encrypted_password, created_at, updated_at
`

type CreateUserParams struct {
	Name              string
	Username          string
	EncryptedPassword string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.Username, arg.EncryptedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.EncryptedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMediaItem = `-- name: DeleteMediaItem :exec
DELETE FROM media_items
  WHERE id = $1::uuid
    AND user_id = $2::uuid
`

type DeleteMediaItemParams struct {
	MediaItemID uuid.UUID
	UserID      uuid.UUID
}

func (q *Queries) DeleteMediaItem(ctx context.Context, arg DeleteMediaItemParams) error {
	_, err := q.db.Exec(ctx, deleteMediaItem, arg.MediaItemID, arg.UserID)
	return err
}

const fetchMediaItem = `-- name: FetchMediaItem :one
SELECT id, user_id, title, url, item_type, published_at, created_at, updated_at, state, video_file_path, thumbnail_file_path, subtitle_file_paths, transcript, metadata
  FROM media_items
  WHERE id = $1::uuid
`

func (q *Queries) FetchMediaItem(ctx context.Context, mediaItemID uuid.UUID) (MediaItem, error) {
	row := q.db.QueryRow(ctx, fetchMediaItem, mediaItemID)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.ItemType,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
		&i.VideoFilePath,
		&i.ThumbnailFilePath,
		&i.SubtitleFilePaths,
		&i.Transcript,
		&i.Metadata,
	)
	return i, err
}

const fetchMediaItemForUser = `-- name: FetchMediaItemForUser :one
SELECT id, user_id, title, url, item_type, published_at, created_at, updated_at, state, video_file_path, thumbnail_file_path, subtitle_file_paths, transcript, metadata FROM media_items
  WHERE id = $1::uuid
    AND user_id = $2::uuid
  LIMIT 1
`

type FetchMediaItemForUserParams struct {
	MediaItemID uuid.UUID
	UserID      uuid.UUID
}

func (q *Queries) FetchMediaItemForUser(ctx context.Context, arg FetchMediaItemForUserParams) (MediaItem, error) {
	row := q.db.QueryRow(ctx, fetchMediaItemForUser, arg.MediaItemID, arg.UserID)
	var i MediaItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.ItemType,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
		&i.VideoFilePath,
		&i.ThumbnailFilePath,
		&i.SubtitleFilePaths,
		&i.Transcript,
		&i.Metadata,
	)
	return i, err
}

const fetchMediaItemTopicsForMediaItems = `-- name: FetchMediaItemTopicsForMediaItems :many
SELECT mit.id, mit.media_item_id, mit.topic_id, mit.confirmed_at, mit.created_at, mit.updated_at
  FROM media_item_topics mit
  INNER JOIN media_items mi ON mi.id = mit.media_item_id
  WHERE mit.media_item_id = ANY($1::uuid[])
    AND mi.user_id = $2::uuid
`

type FetchMediaItemTopicsForMediaItemsParams struct {
	MediaItemIds []uuid.UUID
	UserID       uuid.UUID
}

func (q *Queries) FetchMediaItemTopicsForMediaItems(ctx context.Context, arg FetchMediaItemTopicsForMediaItemsParams) ([]MediaItemTopic, error) {
	rows, err := q.db.Query(ctx, fetchMediaItemTopicsForMediaItems, arg.MediaItemIds, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaItemTopic
	for rows.Next() {
		var i MediaItemTopic
		if err := rows.Scan(
			&i.ID,
			&i.MediaItemID,
			&i.TopicID,
			&i.ConfirmedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMediaItemsByID = `-- name: FetchMediaItemsByID :many
SELECT id, user_id, title, url, item_type, published_at, created_at, updated_at, state, video_file_path, thumbnail_file_path, subtitle_file_paths, transcript, metadata
  FROM media_items
  WHERE id = ANY($1::uuid[])
    AND user_id = $2::uuid
`

type FetchMediaItemsByIDParams struct {
	MediaItemIds []uuid.UUID
	UserID       uuid.UUID
}

func (q *Queries) FetchMediaItemsByID(ctx context.Context, arg FetchMediaItemsByIDParams) ([]MediaItem, error) {
	rows, err := q.db.Query(ctx, fetchMediaItemsByID, arg.MediaItemIds, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaItem
	for rows.Next() {
		var i MediaItem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.ItemType,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.State,
			&i.VideoFilePath,
			&i.ThumbnailFilePath,
			&i.SubtitleFilePaths,
			&i.Transcript,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTopicsForMediaItem = `-- name: FetchTopicsForMediaItem :many
SELECT t.id, t.user_id, t.name, t.description, t.created_at, t.updated_at
  FROM media_item_topics mit
  INNER JOIN media_items mi ON mi.id = mit.media_item_id
  INNER JOIN topics t ON t.id = mit.topic_id
  WHERE mit.media_item_id = $1::uuid
    AND mi.user_id = $2::uuid
`

type FetchTopicsForMediaItemParams struct {
	MediaItemID uuid.UUID
	UserID      uuid.UUID
}

func (q *Queries) FetchTopicsForMediaItem(ctx context.Context, arg FetchTopicsForMediaItemParams) ([]Topic, error) {
	rows, err := q.db.Query(ctx, fetchTopicsForMediaItem, arg.MediaItemID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByUsername = `-- name: FetchUserByUsername :one
SELECT id, name, username, encrypted_password, created_at, updated_at FROM users
WHERE username = $1::text LIMIT 1
`

func (q *Queries) FetchUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, fetchUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.EncryptedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markMediaItemAsProcessing = `-- name: MarkMediaItemAsProcessing :exec
UPDATE media_items
  SET state = 'processing'
  WHERE id = $1::uuid
`

func (q *Queries) MarkMediaItemAsProcessing(ctx context.Context, mediaItemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markMediaItemAsProcessing, mediaItemID)
	return err
}

const markVideoMediaItemAsProcessed = `-- name: MarkVideoMediaItemAsProcessed :exec
UPDATE media_items
  SET state = 'processed', video_file_path = $1::text, thumbnail_file_path = $2::text, subtitle_file_paths = $3::text[], transcript = $4::text, title = $5::text, metadata = $6::jsonb, published_at = $7::timestamp
  WHERE id = $8::uuid
`

type MarkVideoMediaItemAsProcessedParams struct {
	VideoFilePath     string
	ThumbnailFilePath string
	SubtitleFilePaths []string
	Transcript        string
	Title             string
	Metadata          dbtypes.JSON
	PublishedAt       pgtype.Timestamp
	MediaItemID       uuid.UUID
}

func (q *Queries) MarkVideoMediaItemAsProcessed(ctx context.Context, arg MarkVideoMediaItemAsProcessedParams) error {
	_, err := q.db.Exec(ctx, markVideoMediaItemAsProcessed,
		arg.VideoFilePath,
		arg.ThumbnailFilePath,
		arg.SubtitleFilePaths,
		arg.Transcript,
		arg.Title,
		arg.Metadata,
		arg.PublishedAt,
		arg.MediaItemID,
	)
	return err
}

const removeTopicFromMediaItem = `-- name: RemoveTopicFromMediaItem :exec
DELETE FROM media_item_topics
WHERE user_id = $1::uuid AND media_item_id = $2::uuid AND topic_id = $3::uuid
`

type RemoveTopicFromMediaItemParams struct {
	UserID      uuid.UUID
	MediaItemID uuid.UUID
	TopicID     uuid.UUID
}

func (q *Queries) RemoveTopicFromMediaItem(ctx context.Context, arg RemoveTopicFromMediaItemParams) error {
	_, err := q.db.Exec(ctx, removeTopicFromMediaItem, arg.UserID, arg.MediaItemID, arg.TopicID)
	return err
}

const searchMediaItems = `-- name: SearchMediaItems :many
SELECT id, user_id, title, url, item_type, published_at, created_at, updated_at, state, video_file_path, thumbnail_file_path, subtitle_file_paths, transcript, metadata 
  FROM media_items
  WHERE user_id = $1::uuid
    AND title ILIKE '%' || $2::text || '%'
    AND state = 'processed'
  ORDER BY published_at DESC
  LIMIT $4::int
  OFFSET $3::int
`

type SearchMediaItemsParams struct {
	UserID     uuid.UUID
	Query      string
	PageOffset int32
	PageLimit  int32
}

func (q *Queries) SearchMediaItems(ctx context.Context, arg SearchMediaItemsParams) ([]MediaItem, error) {
	rows, err := q.db.Query(ctx, searchMediaItems,
		arg.UserID,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaItem
	for rows.Next() {
		var i MediaItem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.ItemType,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.State,
			&i.VideoFilePath,
			&i.ThumbnailFilePath,
			&i.SubtitleFilePaths,
			&i.Transcript,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTopics = `-- name: SearchTopics :many
SELECT id, user_id, name, description, created_at, updated_at
  FROM topics
  WHERE user_id = $1::uuid
    AND name ILIKE '%' || $2::text || '%'
  ORDER BY name ASC
  LIMIT $4::int
  OFFSET $3::int
`

type SearchTopicsParams struct {
	UserID     uuid.UUID
	Query      string
	PageOffset int32
	PageLimit  int32
}

func (q *Queries) SearchTopics(ctx context.Context, arg SearchTopicsParams) ([]Topic, error) {
	rows, err := q.db.Query(ctx, searchTopics,
		arg.UserID,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
